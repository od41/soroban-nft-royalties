#![no_std]
use soroban_sdk::{contracterror, contractimpl, Env, Address, Map, Symbol, ConversionError};

#[contracterror]
#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]
#[repr(u32)]
pub enum Error {
    AdminNotSet = 1,
    AssetNotFound = 2,
}

#[derive(Clone)]
#[contracttype]
pub struct Asset {
    asset: Address,
    royalty_recipient: Address,
    royalty_amount: u32,
};

const ADMIN: Symbol = Symbol::short("ADMIN");
const ASSETS: Symbol = Symbol::short("ASSETS");

pub struct AssetContract;

#[contractimpl]
impl AssetContract {
    pub fn init(e: Env, admin: Address) -> Result<(), Error> {
        e.storage().set(&ADMIN, &admin);
        Ok(())
    }

    pub fn set_asset(e: Env, asset: Address, royalty_recipient: Address, royalty_amount: u32) -> Result<(), Error> {
        let admin: Address = e.storage().get(&ADMIN).unwrap_or(Err(ConversionError)).map_err(|_| Error::AdminNotSet)?;
        if e.caller() != admin {
            return Err(Error::AdminNotSet);
        }
        let mut assets: Map<Address, Asset> = e.storage().get(&ASSETS).unwrap_or(Ok(Map::new(&e))).unwrap();
        assets.set(asset, Asset {
            asset,
            royalty_recipient,
            royalty_amount,
        });
        e.storage().set(&ASSETS, &assets);
        Ok(())
    }

    pub fn get_asset(e: Env, asset: Address) -> Result<Asset, Error> {
        let assets: Map<Address, Asset> = e.storage().get(&ASSETS).unwrap_or(Ok(Map::new(&e))).unwrap();
        assets.get(asset).unwrap_or_else(|_| Err(Error::AssetNotFound))
    }
}
